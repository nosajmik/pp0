<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

    <script>
        // Artifact repository for PP0 - for more information see
        // https://github.com/yossioren/pp0

        // if false, measure time. if true, measure how many cache sweeps we get until the clock changes
        const COUNT_SWEEPS = false;

        /*
         Constants for cache size - pp0 used an i5-3470 for evaluation,
         which has a 6MB LLC with 12 ways. Hence 6 MB / 12 ways / 64 bytes per line
         = 8192 cache sets. -nosajmik
         */
        const CACHE_SETS = 8192; const CACHE_WAYS = 12;
        const SET_SKIPPING_STEP = 2;

        // To try out COUNT_SWEEPS mode (e.g. on the Tor Browser), 
        // increase SAMPLING_PERIOD_IN_MS to 100 and reduce MEASUREMENT_COUNT accordingly
        const MEASUREMENT_COUNT = 500;
        const SAMPLING_PERIOD_IN_MS = 2;

        const BYTES_PER_MB = 1024 * 1024;
        const BYTES_PER_LINE = 64;
        // 4KB page / 64 bytes per cache line = 64 cache sets per page
        const SETS_PER_PAGE = 64;

        var PP;
        var resultArray = {};


        // Prime and probe object
        function PrimeProbe(sets, ways) {
            // Traversed to flush LLC
            this.evictionArray = new Uint32Array(32 * BYTES_PER_MB / Uint32Array.BYTES_PER_ELEMENT);
            // Contains the starting indices for pointer chasing for each cache set in a page
            this.setHeads = new Array(SETS_PER_PAGE);

            this.probeSet = function (setOffset) {
                // Performs pointer chasing to access LLC-sized buffer s.t.
                // loads are serially dependent; prevents reordering or combining
                // loads, or the prefetcher. -nosajmik
                var pointer = this.setHeads[setOffset];
                var listHead = pointer;
                do {
                    pointer = this.evictionArray[pointer];
                } while (pointer != listHead);
                return pointer;
            }

            this.probeAllSets = function () {
                var p;
                // Every other set
                for (var set = 0; set < SETS_PER_PAGE; set += SET_SKIPPING_STEP) {
                    p = this.probeSet(set);
                }

                return p;
            }

            this.shuffle = function (arrayToShuffle) {
                var tmp, current, top = arrayToShuffle.length;
                if (top) while (--top) {
                    current = Math.floor(Math.random() * (top + 1));
                    tmp = arrayToShuffle[current];
                    arrayToShuffle[current] = arrayToShuffle[top];
                    arrayToShuffle[top] = tmp;
                }

                return arrayToShuffle;
            }

            this.createSetHeads = function (sets, ways) {
                // 128 pages needed to cover all LLC sets
                var unshuffledArray = new Uint32Array(sets / SETS_PER_PAGE);
                // The + 4 comes from evictionArray being a Uint32Array (see below) -nosajmik
                var allSetOffset = Math.log2(sets) + 4; // 17 for sets=8192, 16 for sets=4096
                var i;
                for (i = 0; i < unshuffledArray.length; i++) {
                    unshuffledArray[i] = i;
                }

                // Shuffle the array
                var shuffledArray = this.shuffle(unshuffledArray);

                // Now write into the eviction buffer
                var set_index, element_index, line_index;
                var currentElement, nextElement;

                for (set_index = 0; set_index < SETS_PER_PAGE; set_index++) {
                    // nosajmik: the shifts of 10 and 4 are because evictionArray is
                    // a Uint32Array - where each array element is 32 bits = 4 bytes long,
                    // requiring log_2 4 = 2 bits for indexing. Hence the << 10 is effectively
                    // << 12 for memory addresses, which is identical to * 4096 (page size), 
                    // and the << 4 is effectively << 6 for addresses, which is identical to 
                    // * 64 (cache line size). 
                    currentElement = (shuffledArray[0] << 10) + (set_index << 4);
                    this.setHeads[set_index] = currentElement;
                    // Outer loop iterates over cache ways, inner loop over the pages needed to cover all LLC sets
                    for (line_index = 0; line_index < ways; line_index++) {
                        for (element_index = 0; element_index < sets / SETS_PER_PAGE - 1; element_index++) {
                            nextElement = (line_index << allSetOffset) + (shuffledArray[element_index + 1] << 10) + (set_index << 4);
                            this.evictionArray[currentElement] = nextElement;
                            currentElement = nextElement;
                        } // element

                        if (line_index == ways - 1) {
                            // In the last line, the last pointer goes to the head of the entire set
                            nextElement = this.setHeads[set_index];
                        } else {
                            // Last pointer goes back to the head of the next line
                            nextElement = ((line_index + 1) << allSetOffset) + (shuffledArray[0] << 10) + (set_index << 4);
                        }

                        this.evictionArray[currentElement] = nextElement;
                        currentElement = nextElement;
                    } // line
                } // set
            };

            this.createSetHeads(sets, ways);
        } // PP object.


        function createPPObject(sets, ways) {
            PP = new PrimeProbe(sets, ways);
        }


        function probeAllSets() {
            var startTime = performance.now();
            PP.probeAllSets();
            return (performance.now() - startTime);
        }


        function performMeasurement() {
            console.log("Starting measurement")

            // Set up the result array
            resultArray = new Array(MEASUREMENT_COUNT);
            var nextMeasurementStartTime, currentTime;

            nextMeasurementStartTime = performance.now() + SAMPLING_PERIOD_IN_MS;

            // Spin until we're ready for the next measurement
            do {
                // nosajmik: performance.now() returns a relatively high-resolution
                // timestamp of time elapsed since page load. Subtracting two calls to
                // performance.now() gives the time delta.
                currentTime = performance.now();
            }
            while (currentTime < nextMeasurementStartTime);

            // For each measurement period
            var measurement_index;
            for (measurement_index = 0; measurement_index < MEASUREMENT_COUNT; measurement_index++) {

                // Prepare for the next measurement
                nextMeasurementStartTime += SAMPLING_PERIOD_IN_MS;

                if (COUNT_SWEEPS == true) {
                    var sweeps = 0;
                    // repeatedly perform the measurement until the clock changes
                    // nosajmik: sweeps are basically repeating the measurement to amplify
                    // timing differences, if we have a very coarse-grained timer.
                    do {
                        currentTime = performance.now();
                        sweeps++;
                        PP.probeAllSets();
                    } while (currentTime < nextMeasurementStartTime);
                } else {
                    // otherwise, perform the measurement
                    PP.probeAllSets(SET_SKIPPING_STEP);
                }

                // Log the time it took
                if (COUNT_SWEEPS == true) {
                    // log how many spins it took until the clock ticked again
                    resultArray[measurement_index] = sweeps;
                } else {
                    resultArray[measurement_index] = (performance.now() - currentTime).toFixed(3);
                }

                // Spin until the next measurement starts
                do {
                    currentTime = performance.now();
                }
                while (currentTime < nextMeasurementStartTime);
            }

            console.log('Trace returned: ' + resultArray);
            document.getElementById("results").innerHTML = resultArray;
            console.log("Finished measurement")
        }


        function go() {
            console.log("Starting...")
            createPPObject(CACHE_SETS, CACHE_WAYS);
            performMeasurement();
        }
    </script>
</head>

<body onload="go()">
</body>
 
<div id="results" style="width:100%; word-wrap: break-word;"></div>
<br>
<a href="https://github.com/Yossioren/pp0">For more information</a>
</html>